<script setup>
  import img from '/imgs/算法/完全二叉树.png'
</script>

## 二叉树的种类

### 满二叉树

> 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是(2^k) -1 ，则它就是满二叉树。

### 完全二叉树

> 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。
>
> 如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树。

<img :src="img" alt="完全二叉树"/>

### 二叉搜索树

> 前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。
>
> - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
> - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
> - 它的左、右子树也分别为二叉排序树

### 平衡二叉搜索树

> 平衡二叉树是一种二叉排序树，其中每个结点的左子树和右子树的**高度差至多等于1**。是两位俄罗斯数学家(G.M,Adelons-V.MLandis)共同发明的一种解决平衡二叉树的算法，也称之为**AVL树**。

## 二叉树的遍历方式

二叉树主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- **深度优先遍历**(前中后其实就代表了根节点的在哪个位置，下面加粗字体可以明显看出来)
  - 前序遍历（递归法，迭代法）, 遍历顺序：**中**->左->右
  - 中序遍历（递归法，迭代法）, 遍历顺序：左->**中**->右
  - 后序遍历（递归法，迭代法）, 遍历顺序：左->右->**中**
- **广度优先遍历**
  - 层次遍历（迭代法）

我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

**栈其实就是递归的一种实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

## 二叉树的代码实现

```typescript
class TreeNode {
    public val: number
    public left: TreeNode | null
    public right: TreeNode | null
    constructor(val?: number, left?: TreeNode, right?: TreeNode) {
        this.val = val === undefined ? 0 : val
        this.left = left === undefined ? null : left
        this.right = right === undefined ? null : right
    }
}
```

